[["crohn_dissease.html", "Portfolio FFR 1 Crohn_dissease", " Portfolio FFR FFR 2024-11-20 1 Crohn_dissease crohns_dissease_seurat &lt;- readRDS(url(&quot;https://datasets.cellxgene.cziscience.com/7afb64af-cd3b-44ed-bd2a-3d7bd8a98e13.rds&quot;)) # Extract raw counts and metadata to create SingleCellExperiment object counts &lt;- crohns_dissease_seurat@assays$RNA@counts metadata &lt;- crohns_dissease_seurat@meta.data # Plot violin plots for QC metrics VlnPlot(crohns_dissease_seurat, features = c(&quot;nFeaturess_RNA&quot;, &quot;nCounts_RNA&quot;, &quot;percent_mito&quot;), ncol = 3, pt.size = FALSE) #setting the limits on exceptable values to select alowing some [10%] mitochondrial dna into the data set subset_crohns_dissease &lt;- subset(crohns_dissease_seurat, subset = nFeaturess_RNA &gt; 200 &amp; nFeaturess_RNA &lt; 2500 &amp; percent_mito &lt; 10) VlnPlot(subset_crohns_dissease, features = c(&quot;nFeaturess_RNA&quot;, &quot;nCounts_RNA&quot;, &quot;percent_mito&quot;), ncol = 3, pt.size = FALSE) plot1 &lt;- FeatureScatter(subset_crohns_dissease, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;percent_mito&quot;) plot2 &lt;- FeatureScatter(subset_crohns_dissease, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;nFeaturess_RNA&quot;) plot1 + plot2 # Normalize the data norm_subset_crohns_dissease &lt;- NormalizeData(subset_crohns_dissease) # getting rownames into object ensembl_ids &lt;- rownames(crohns_dissease_seurat@assays$RNA@counts) # loading in ensemble ids and human genes ensembl &lt;- useEnsembl(biomart = &quot;genes&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) # using the biomart to extract gene ids from ensemble gen ids gene_mapping &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) # pasting the names and ensamble ids together with setnames and creating a sepperate object for later use gene_name_map &lt;- setNames(gene_mapping$hgnc_symbol, gene_mapping$ensembl_gene_id) # Find variable features FVF_crohns_dissease &lt;- FindVariableFeatures(norm_subset_crohns_dissease, selection.method = &quot;vst&quot;) # load variable features into object variable_features &lt;- VariableFeatures(FVF_crohns_dissease) # Map variable features to gene names variable_features_gene_names &lt;- gene_name_map[variable_features] # Handle NA values (e.g., unmapped IDs) variable_features_gene_names &lt;- ifelse( is.na(variable_features_gene_names), variable_features, # Use Ensembl ID if no gene name variable_features_gene_names ) # Extract top 10 variable genes top10_gene_names &lt;- head(variable_features_gene_names, 10) # Plot variable features plot3 &lt;- VariableFeaturePlot(FVF_crohns_dissease) # Label points with gene names plot4 &lt;- LabelPoints( plot = plot3, points = head(variable_features, 10), labels = top10_gene_names, repel = TRUE ) ## When using repel, set xnudge and ynudge to 0 for optimal results # Display the plot plot4 ## Warning in scale_x_log10(): log-10 transformation introduced ## infinite values. scaled_data &lt;- ScaleData(FVF_crohns_dissease, features = VariableFeatures(FVF_crohns_dissease)) ## Centering and scaling data matrix pca_crohns &lt;- RunPCA(scaled_data, features = VariableFeatures(object = scaled_data)) ## PC_ 1 ## Positive: ENSG00000152583, ENSG00000163453, ENSG00000122786, ENSG00000175899, ENSG00000113140, ENSG00000142089, ENSG00000169908, ENSG00000164692, ENSG00000148180, ENSG00000165949 ## ENSG00000189171, ENSG00000168542, ENSG00000127920, ENSG00000004799, ENSG00000162407, ENSG00000176907, ENSG00000106538, ENSG00000182326, ENSG00000141753, ENSG00000139329 ## ENSG00000100234, ENSG00000118523, ENSG00000250722, ENSG00000011465, ENSG00000134028, ENSG00000211445, ENSG00000106565, ENSG00000000971, ENSG00000101335, ENSG00000067113 ## Negative: ENSG00000110848, ENSG00000111796, ENSG00000271503, ENSG00000134285, ENSG00000227507, ENSG00000170476, ENSG00000211751, ENSG00000105369, ENSG00000132465, ENSG00000048462 ## ENSG00000099958, ENSG00000158050, ENSG00000211890, ENSG00000169508, ENSG00000211592, ENSG00000166562, ENSG00000211895, ENSG00000153563, ENSG00000180879, ENSG00000275302 ## ENSG00000105374, ENSG00000134539, ENSG00000100219, ENSG00000184451, ENSG00000172116, ENSG00000211679, ENSG00000115738, ENSG00000227191, ENSG00000109471, ENSG00000211677 ## PC_ 2 ## Positive: ENSG00000171345, ENSG00000145384, ENSG00000127324, ENSG00000119888, ENSG00000136872, ENSG00000171747, ENSG00000165828, ENSG00000095932, ENSG00000189334, ENSG00000114113 ## ENSG00000233041, ENSG00000165215, ENSG00000267795, ENSG00000173467, ENSG00000243955, ENSG00000171431, ENSG00000163586, ENSG00000166920, ENSG00000170421, ENSG00000166825 ## ENSG00000015413, ENSG00000197273, ENSG00000124253, ENSG00000181885, ENSG00000164266, ENSG00000099834, ENSG00000163435, ENSG00000183844, ENSG00000197249, ENSG00000010438 ## Negative: ENSG00000122786, ENSG00000168542, ENSG00000164692, ENSG00000175899, ENSG00000139329, ENSG00000182326, ENSG00000163453, ENSG00000113140, ENSG00000134028, ENSG00000152583 ## ENSG00000011465, ENSG00000159403, ENSG00000077942, ENSG00000142173, ENSG00000106538, ENSG00000000971, ENSG00000166482, ENSG00000145824, ENSG00000164176, ENSG00000211445 ## ENSG00000118526, ENSG00000162407, ENSG00000108821, ENSG00000163359, ENSG00000197766, ENSG00000141338, ENSG00000087245, ENSG00000130203, ENSG00000169908, ENSG00000115461 ## PC_ 3 ## Positive: ENSG00000110077, ENSG00000090382, ENSG00000132514, ENSG00000173372, ENSG00000204472, ENSG00000011600, ENSG00000106066, ENSG00000121552, ENSG00000166927, ENSG00000173369 ## ENSG00000140749, ENSG00000159189, ENSG00000231389, ENSG00000223865, ENSG00000196735, ENSG00000127951, ENSG00000158869, ENSG00000179344, ENSG00000196126, ENSG00000155659 ## ENSG00000188820, ENSG00000204287, ENSG00000204257, ENSG00000197629, ENSG00000169413, ENSG00000163563, ENSG00000172243, ENSG00000101439, ENSG00000216490, ENSG00000242574 ## Negative: ENSG00000168542, ENSG00000164692, ENSG00000139329, ENSG00000182326, ENSG00000011465, ENSG00000106538, ENSG00000166482, ENSG00000077942, ENSG00000159403, ENSG00000142173 ## ENSG00000145824, ENSG00000164176, ENSG00000118526, ENSG00000122786, ENSG00000108821, ENSG00000163359, ENSG00000141338, ENSG00000158747, ENSG00000115461, ENSG00000134028 ## ENSG00000087245, ENSG00000214548, ENSG00000090006, ENSG00000134285, ENSG00000140416, ENSG00000211445, ENSG00000145681, ENSG00000105894, ENSG00000148671, ENSG00000138080 ## PC_ 4 ## Positive: ENSG00000139329, ENSG00000134028, ENSG00000197766, ENSG00000011465, ENSG00000168542, ENSG00000182326, ENSG00000164692, ENSG00000077942, ENSG00000145824, ENSG00000166482 ## ENSG00000130203, ENSG00000164176, ENSG00000106538, ENSG00000159403, ENSG00000118526, ENSG00000141338, ENSG00000108821, ENSG00000142173, ENSG00000214548, ENSG00000163359 ## ENSG00000145681, ENSG00000038427, ENSG00000138080, ENSG00000087245, ENSG00000105894, ENSG00000163739, ENSG00000099998, ENSG00000106565, ENSG00000115461, ENSG00000196616 ## Negative: ENSG00000130300, ENSG00000184113, ENSG00000131477, ENSG00000168497, ENSG00000172889, ENSG00000127329, ENSG00000102755, ENSG00000105974, ENSG00000163762, ENSG00000162618 ## ENSG00000164035, ENSG00000122679, ENSG00000110799, ENSG00000149564, ENSG00000154721, ENSG00000167775, ENSG00000166265, ENSG00000249751, ENSG00000129538, ENSG00000261371 ## ENSG00000167874, ENSG00000150687, ENSG00000267107, ENSG00000135218, ENSG00000136960, ENSG00000137962, ENSG00000128567, ENSG00000179776, ENSG00000170989, ENSG00000182809 ## PC_ 5 ## Positive: ENSG00000170476, ENSG00000132465, ENSG00000211895, ENSG00000048462, ENSG00000099958, ENSG00000211890, ENSG00000211592, ENSG00000180879, ENSG00000166562, ENSG00000100219 ## ENSG00000123131, ENSG00000166598, ENSG00000105369, ENSG00000051108, ENSG00000211677, ENSG00000211679, ENSG00000184451, ENSG00000128228, ENSG00000135916, ENSG00000254709 ## ENSG00000134285, ENSG00000243290, ENSG00000222037, ENSG00000211640, ENSG00000119655, ENSG00000100097, ENSG00000211685, ENSG00000173334, ENSG00000273802, ENSG00000211673 ## Negative: ENSG00000075624, ENSG00000111796, ENSG00000110848, ENSG00000115738, ENSG00000271503, ENSG00000100906, ENSG00000184009, ENSG00000167996, ENSG00000034510, ENSG00000211751 ## ENSG00000275302, ENSG00000227507, ENSG00000105374, ENSG00000103187, ENSG00000169508, ENSG00000134539, ENSG00000153563, ENSG00000111640, ENSG00000158050, ENSG00000164056 ## ENSG00000276070, ENSG00000164104, ENSG00000139289, ENSG00000145649, ENSG00000197956, ENSG00000172116, ENSG00000160593, ENSG00000227191, ENSG00000109471, ENSG00000143185 #VizDimLoadings(pca_crohns, dims = 1:8, reduction = &quot;pca&quot;, combine = FALSE) DimPlot(pca_crohns, reduction = &quot;pca&quot;) + NoLegend() DimHeatmap(pca_crohns, dims = 1:15, cells = 500, balanced = TRUE) ElbowPlot(pca_crohns) umap_data_crohns &lt;- FindNeighbors(pca_crohns, dims = 1:15) ## Computing nearest neighbor graph ## Computing SNN umap_data_crohns &lt;- FindClusters(umap_data_crohns, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 29915 ## Number of edges: 937472 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9079 ## Number of communities: 19 ## Elapsed time: 5 seconds umap_fig_crohns &lt;- RunUMAP(umap_data_crohns, dims = 1:15) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 09:27:44 UMAP embedding parameters a = 0.9922 b = 1.112 ## 09:27:44 Read 29915 rows and found 15 numeric columns ## 09:27:44 Using Annoy for neighbor search, n_neighbors = 30 ## 09:27:44 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 09:27:46 Writing NN index file to temp file C:\\Users\\ffrij\\AppData\\Local\\Temp\\Rtmp4MRHuY\\file3d1028897317 ## 09:27:46 Searching Annoy index using 1 thread, search_k = 3000 ## 09:27:54 Annoy recall = 100% ## 09:27:54 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 09:27:57 Initializing from normalized Laplacian + noise (using RSpectra) ## 09:28:00 Commencing optimization for 200 epochs, with 1378092 positive edges ## 09:28:29 Optimization finished DimPlot(umap_fig_crohns, reduction = &quot;umap&quot;) # find markers for every cluster compared to all remaining cells, report only the positive ones #This took me 2 hours and 21 minutes crohns.markers &lt;- FindAllMarkers(umap_fig_crohns, only.pos = TRUE) ## Calculating cluster 0 ## For a (much!) faster implementation of the Wilcoxon Rank Sum Test, ## (default method for FindMarkers) please install the presto package ## -------------------------------------------- ## install.packages(&#39;devtools&#39;) ## devtools::install_github(&#39;immunogenomics/presto&#39;) ## -------------------------------------------- ## After installation of presto, Seurat will automatically use the more ## efficient implementation (no further action necessary). ## This message will be shown once per session ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 ## Calculating cluster 9 ## Calculating cluster 10 ## Calculating cluster 11 ## Calculating cluster 12 ## Calculating cluster 13 ## Calculating cluster 14 ## Calculating cluster 15 ## Calculating cluster 16 ## Calculating cluster 17 ## Calculating cluster 18 crohns.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 39,468 × 7 ## # Groups: cluster [19] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 0 1.57 0.809 0.309 0 0 ENSG00000167286 ## 2 0 1.67 0.851 0.355 0 0 ENSG00000111796 ## 3 0 1.36 0.89 0.396 0 0 ENSG00000168685 ## 4 0 1.55 0.751 0.304 0 0 ENSG00000277734 ## 5 0 1.44 0.678 0.27 0 0 ENSG00000116824 ## 6 0 1.67 0.657 0.267 0 0 ENSG00000069667 ## 7 0 1.19 0.744 0.358 0 0 ENSG00000008517 ## 8 0 1.34 0.616 0.246 0 0 ENSG00000198851 ## 9 0 1.59 0.589 0.244 0 0 ENSG00000082074 ## 10 0 1.13 0.779 0.437 0 0 ENSG00000118503 ## # ℹ 39,458 more rows # using the biomart to extract gene ids from ensemble gen ids gene_symbol &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = crohns.markers$gene, mart = ensembl ) gene_symbol &lt;- rename(gene_symbol, gene = &quot;ensembl_gene_id&quot;) pbmc.markers &lt;- left_join(crohns.markers, gene_symbol, by = &quot;gene&quot; ) ## Warning in left_join(crohns.markers, gene_symbol, by = &quot;gene&quot;): Detected an unexpected many-to-many ## relationship between `x` and `y`. ## ℹ Row 1 of `x` matches multiple rows in ## `y`. ## ℹ Row 2345 of `y` matches multiple rows ## in `x`. ## ℹ If a many-to-many relationship is ## expected, set `relationship = ## &quot;many-to-many&quot;` to silence this ## warning. pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% distinct(gene) %&gt;% slice_head(n = 10) %&gt;% ungroup() -&gt; top10 DoHeatmap(umap_fig_crohns, features = top10$gene) + NoLegend() ## Warning in DoHeatmap(umap_fig_crohns, features = top10$gene): The following ## features were omitted as they were not found in the scale.data slot for the RNA ## assay: ENSG00000277459, ENSG00000143297, ENSG00000081237, ENSG00000102245, ## ENSG00000265972, ENSG00000122862, ENSG00000121966, ENSG00000100376, ## ENSG00000213741, ENSG00000164305, ENSG00000196781, ENSG00000077984, ## ENSG00000173762, ENSG00000104894, ENSG00000118363, ENSG00000173486, ## ENSG00000174946, ENSG00000118503, ENSG00000082074, ENSG00000198851, ## ENSG00000008517, ENSG00000069667, ENSG00000116824, ENSG00000277734, ## ENSG00000168685, ENSG00000167286 "],["curriculum-vitae-ffr.html", "2 Curriculum vitae FFR 2.1 Personalia verander zodat er meer is over bioinfo 2.2 Opleiding 2.3 Werkervaring", " 2 Curriculum vitae FFR 2.1 Personalia verander zodat er meer is over bioinfo Naast mijn studie Life Sciences ben ik op zoek naar mogelijkheden om mijn werkervaring verder uit te breiden, met een focus op bioinformatica. Ik heb ervaring in programmeren met R, inclusief R Markdown voor data-analyse en rapportage, evenals C# en Java voor softwareontwikkeling. Ik ben analytisch, nieuwsgierig en altijd bereid om nieuwe technieken te leren. Tijdens mijn opleiding heb ik gewerkt met apparaten zoals de PCR en de BIO-RAD thermal cycler. Daarnaast heb ik onder begeleiding van J. B. uitgebreide ervaring opgedaan met de diagnostiek van virussen, met name door het uitvoeren van qPCR-analyses op patiëntmateriaal. ## ## Attaching package: &#39;gridExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine 2.2 Opleiding 2019-2024 HBO Biologie en Medisch Laboratoriumonderzoek 2014-2019 Tweetalig Havo op het Anna van Rijn Lyceum, Nieuwegein Studierichting: - Natuur &amp; Techniek en Natuur en Gezondheid - Met informatica - IB English B 2.3 Werkervaring 2024 LUMC research technician 2023-2024 Stage: LUMC, LUCID onder suppervisie van Rajagopal A. Murugan 2021-2023 Particuliere studiebegeleider 2023 Stage: IJsselland ziekenhuis microbiologische laboratorium 2019-2021 Verkoopmedewerker Kruidvat Montfoort 2019 Freelancer Go:Office 2018 Bakkerij Jan van Dommelen 2017-2018 Oppas 2015-2016 Hockey training Contact info name lastname dummy@xs4all.nl Tel: +31 6 12 34 56 78 straatnaam 910 1112AB C-oude 13-14-2015 "],["seurat.html", "3 Seurat", " 3 Seurat The Seurat package is an R package that is designed for analysis and visualization of single-cell RNA sequencing (scRNA-seq) data. It is possible to do data normalization, dimensionality reduction (like, PCA and UMAP) and for other forms of analyses (omic if I get to it). I will be using this (https://satijalab.org/seurat/articles/pbmc3k_tutorial) tutorial to start learning the Seurat package. I quote “we will be analyzing the a dataset of Peripheral Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. There are 2,700 single cells that were sequenced on the Illumina NextSeq 500. The raw data can be found here(https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz).” library(dplyr) library(tidyverse) library(Seurat) #install.packages(&quot;Seurat&quot;) library(patchwork) #install.packages(&quot;patchwork&quot;) library(here) # Load the PBMC dataset pbmc.data &lt;- Read10X(data.dir = &quot;Rmd_files/Seurat_10x_data/filtered_gene_bc_matrices/hg19/&quot;) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) ## 1 layer present: counts # Lets examine a few genes in the first thirty cells pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 30 column names &#39;AAACATACAACCAC-1&#39;, &#39;AAACATTGAGCTAC-1&#39;, &#39;AAACATTGATCAGC-1&#39; ... ]] ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . dense.size &lt;- object.size(as.matrix(pbmc.data)) #object.size(): Calculates the memory size of the dense matrix in bytes. #as.matrix(pbmc.data): Converts pbmc.data to a dense matrix format were as normally a parse matrix is used because it takes up less storage/memory sparse.size &lt;- object.size(pbmc.data) sparse.size ## 29905192 bytes #print parse matrix dense.size ## 709591472 bytes #print dense matrix dense.size/sparse.size ## 23.7 bytes #The dense matrix is 23.7 times bigger than the parse # The [[ operator can add columns to object metadata. This is a great place to stash QC stats pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) # Show QC metrics for the first 5 cells head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 # Visualize QC metrics as a violin plot VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; ## utilizing &quot;counts&quot; layer instead. # FeatureScatter is typically used to visualize feature-feature relationships, but can be used # for anything calculated by the object, i.e. columns in object metadata, PC scores etc. plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;, plot.cor = TRUE) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;, plot.cor = TRUE) plot1 + plot2 There are various ways of generating qualtity control metrics. The tutorial suggests filtering away feature counts over 2500 and under 200 and mitochondrial counts higher than 5%. #selecting the subset of data wanted subset_pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) #normalizing the data as to make the numbers more human readable norm_subset_pbmc &lt;- NormalizeData(subset_pbmc) ## Normalizing layer: counts FVF_pbmc &lt;- FindVariableFeatures(norm_subset_pbmc, selection.method = &quot;vst&quot;) ## Finding variable features for layer counts # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(FVF_pbmc)) # plot variable features with and without labels plot3 &lt;- VariableFeaturePlot(FVF_pbmc) plot4 &lt;- LabelPoints(plot = plot3, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results plot3 + NoLegend() + plot4 ## Warning in scale_x_log10(): log-10 transformation introduced ## infinite values. ## log-10 transformation introduced ## infinite values. #retrieve all gene names all.genes &lt;- rownames(FVF_pbmc) #Scales and centers features in the dataset. scaled_FVF_pbmc &lt;- ScaleData(FVF_pbmc, features = all.genes) ## Centering and scaling data matrix #Run a PCA dimensionality reduction. For details about stored PCA calculation parameters PCA_pbmc &lt;- RunPCA(scaled_FVF_pbmc, features = VariableFeatures(object = scaled_FVF_pbmc)) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL, FTH1, LYZ, FCN1, S100A9, TYMP ## FCER1G, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, IFITM3, SPI1, CFP ## PSAP, IFI30, SAT1, COTL1, S100A11, NPC2, GRN, LGALS3, GSTP1, PYCARD ## Negative: MALAT1, LTB, IL32, IL7R, CD2, B2M, ACAP1, CD27, STK17A, CTSW ## CD247, GIMAP5, AQP3, CCL5, SELL, TRAF3IP3, GZMA, MAL, CST7, ITM2A ## MYC, GIMAP7, HOPX, BEX2, LDLRAP1, GZMK, ETS1, ZAP70, TNFAIP8, RIC3 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1, HLA-DRA, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DMA, HLA-DPB1, HLA-DQA2, CD37, HLA-DRB5, HLA-DMB, HLA-DPA1, FCRLA, HVCN1, LTB ## BLNK, P2RX5, IGLL5, IRF8, SWAP70, ARHGAP24, FCGR2B, SMIM14, PPP1R14A, C16orf74 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA, FGFBP2, CTSW, GNLY, B2M, SPON2 ## CCL4, GZMH, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX ## TTC38, APMAP, CTSC, S100A4, IGFBP7, ANXA1, ID2, IL32, XCL1, RHOC ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, HLA-DPA1, CD74, MS4A1, HLA-DRB1, HLA-DRA ## HLA-DRB5, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, CD37, HVCN1, FCRLA, IRF8 ## PLAC8, BLNK, MALAT1, SMIM14, PLD4, P2RX5, IGLL5, LAT2, SWAP70, FCGR2B ## Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU ## HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, PTCRA, CA2, ACRBP, MMD, TREML1 ## NGFRAP1, F13A1, SEPT5, RUFY1, TSC22D1, MPP1, CMTM5, RP11-367G6.3, MYL9, GP1BA ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1, CD74, HIST1H2AC, HLA-DPB1, PF4, SDPR ## TCL1A, HLA-DRB1, HLA-DPA1, HLA-DQA2, PPBP, HLA-DRA, LINC00926, GNG11, SPARC, HLA-DRB5 ## GP9, AP001189.4, CA2, PTCRA, CD9, NRGN, RGS18, CLU, TUBB1, GZMB ## Negative: VIM, IL7R, S100A6, IL32, S100A8, S100A4, GIMAP7, S100A10, S100A9, MAL ## AQP3, CD2, CD14, FYB, LGALS2, GIMAP4, ANXA1, CD27, FCN1, RBP7 ## LYZ, S100A11, GIMAP5, MS4A6A, S100A12, FOLR3, TRABD2A, AIF1, IL8, IFI6 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY, CCL4, CST7, PRF1, GZMA, SPON2 ## GZMH, S100A9, LGALS2, CCL3, CTSW, XCL2, CD14, CLIC3, S100A12, RBP7 ## CCL5, MS4A6A, GSTP1, FOLR3, IGFBP7, TYROBP, TTC38, AKR1C3, XCL1, HOPX ## Negative: LTB, IL7R, CKB, VIM, MS4A7, AQP3, CYTIP, RP11-290F20.3, SIGLEC10, HMOX1 ## LILRB2, PTGES3, MAL, CD27, HN1, CD2, GDI2, CORO1B, ANXA5, TUBA1B ## FAM110A, ATP1A1, TRADD, PPA1, CCDC109B, ABRACL, CTD-2006K23.1, WARS, VMO1, FYB # Examine and visualize PCA results a few different ways print(PCA_pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 #Visualize the top genes and the first two principle components VizDimLoadings(PCA_pbmc, dims = 1:2, reduction = &quot;pca&quot;) #A PCA plot depicting the each cell and where they get position measured against PC1 and PC2 DimPlot(PCA_pbmc, reduction = &quot;pca&quot;) + NoLegend() DimHeatmap(PCA_pbmc, dims = 1, cells = 500, balanced = TRUE) #By suggesting to the DimHeatmap function to look at PC1 through 15 it will try to fit 15 heatmaps based on the PC previously calculated in PCA_pbmc DimHeatmap(PCA_pbmc, dims = 1:15, cells = 500, balanced = TRUE) ## Dementionality Determining the amount of PC that need to be used is important as to not have a overly computationally expensive. The more PC’s used has diminishing marginal results. This can be done visually by using ElbowPlot(). Alot of the deviation in the graphs can be explained in the first 10 of the principle coordinates. The differences produced in PC 10 - 20 are less distinctionable from background than the first 10. ElbowPlot(PCA_pbmc) findneighbour_pbmc &lt;- FindNeighbors(PCA_pbmc, dims = 1:10) # selecting the top 10 pc&#39;s ## Computing nearest neighbor graph ## Computing SNN clustered_pbmc &lt;- FindClusters(findneighbour_pbmc, resolution = 0.5) # clustering the PC&#39;s ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds rUMAP_pbmc &lt;- RunUMAP(clustered_pbmc, dims = 1:10) ## 11:32:16 UMAP embedding parameters a = 0.9922 b = 1.112 ## 11:32:16 Read 2638 rows and found 10 numeric columns ## 11:32:16 Using Annoy for neighbor search, n_neighbors = 30 ## 11:32:16 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 11:32:17 Writing NN index file to temp file C:\\Users\\ffrij\\AppData\\Local\\Temp\\Rtmp4MRHuY\\file3d10602c126f ## 11:32:17 Searching Annoy index using 1 thread, search_k = 3000 ## 11:32:17 Annoy recall = 100% ## 11:32:18 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 11:32:19 Initializing from normalized Laplacian + noise (using RSpectra) ## 11:32:19 Commencing optimization for 500 epochs, with 105140 positive edges ## 11:32:25 Optimization finished # note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(rUMAP_pbmc, reduction = &quot;umap&quot;) cluster2.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 2) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.892340e-90 1.3070772 0.947 0.465 3.966555e-86 ## LTB 1.060121e-86 1.3312674 0.981 0.643 1.453850e-82 ## CD3D 8.794641e-71 1.0597620 0.922 0.432 1.206097e-66 ## IL7R 3.516098e-68 1.4377848 0.750 0.326 4.821977e-64 ## LDHB 1.642480e-67 0.9911924 0.954 0.614 2.252497e-63 # find all markers distinguishing cluster 5 from clusters 0 and 3 cluster5.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 5, ident.2 = c(0, 3)) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 8.246578e-205 6.794969 0.975 0.040 1.130936e-200 ## IFITM3 1.677613e-195 6.192558 0.975 0.049 2.300678e-191 ## CFD 2.401156e-193 6.015172 0.938 0.038 3.292945e-189 ## CD68 2.900384e-191 5.530330 0.926 0.035 3.977587e-187 ## RP11-290F20.3 2.513244e-186 6.297999 0.840 0.017 3.446663e-182 pbmc.markers &lt;- FindAllMarkers(rUMAP_pbmc, only.pos = TRUE) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows # find markers for every cluster compared to all remaining cells, report only the positive ones pbmc.markers &lt;- FindAllMarkers(rUMAP_pbmc, only.pos = TRUE) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows cluster0.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) VlnPlot(rUMAP_pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) # you can plot raw counts as well VlnPlot(rUMAP_pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) ## Warning: The `slot` argument of `VlnPlot()` is ## deprecated as of Seurat 5.0.0. ## ℹ Please use the `layer` argument ## instead. ## This warning is displayed once every 8 ## hours. ## Call ## `lifecycle::last_lifecycle_warnings()` ## to see where this warning was generated. FeaturePlot(rUMAP_pbmc, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot;)) pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 10) %&gt;% ungroup() -&gt; top10 DoHeatmap(rUMAP_pbmc, features = top10$gene) + NoLegend() new.cluster.ids &lt;- c(&quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot;) names(new.cluster.ids) &lt;- levels(rUMAP_pbmc) top10_genes_pbmc &lt;- RenameIdents(rUMAP_pbmc, new.cluster.ids) DimPlot(top10_genes_pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
