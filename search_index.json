[["index.html", "Portfolio FFR 1 Portfolio FFR", " Portfolio FFR FFR 2024-12-02 1 Portfolio FFR "],["single-cell-analysis-of-crohns-dissease.html", "2 Single cell analysis of Crohn’s dissease 2.1 Libraries used 2.2 Loading in the data set from the CZ CELLxGENE database 2.3 QC subsetting 2.4 Preperations 2.5 Variable features plot 2.6 PCA", " 2 Single cell analysis of Crohn’s dissease Crohn’s dissease is characterized by chronic inflammation of the gastrointestinal [GI] tract. This causes the patient to suffer from diarrhea, stomach aches, fevers, weight loss, tiredness and blood in the feaces. This document got the data from CZ CELLxGENE database [https://cellxgene.cziscience.com/collections/2b02dff7-e427-4cdc-96fb-c0f354c099aa] and this data was collected in this [https://pmc.ncbi.nlm.nih.gov/articles/PMC7060942/] study. The method of this study is to firstly isolate lamina propria cells from both uninflamed and inflamed biopsies of 11 patients. The the 22 ileal specimens where used for single-cell transcriptomics and a UMI identifier is used to differentiate the samples. 2.1 Libraries used library(dplyr) library(tidyverse) library(Seurat) library(ggplot2) #install.packages(&quot;Seurat&quot;) library(patchwork) #install.packages(&quot;patchwork&quot;) library(here) #install.packages(biomaRt) #library(biomaRt) library(grid) library(gridExtra) 2.2 Loading in the data set from the CZ CELLxGENE database I do have a local copy due to not necessarily wanting to fully rely on the database. The decision was eventually made to make the crohns_dissease_seurat object from the url provided in the database. Due to being unable to provide the data set in the same github repository as the other files in this portfolio. This is the best solution i could come up with wanting to make this open and reproducible science. crohns_dissease_seurat &lt;- readRDS(url(&quot;https://datasets.cellxgene.cziscience.com/7afb64af-cd3b-44ed-bd2a-3d7bd8a98e13.rds&quot;)) 2.3 QC subsetting Quality control is always a very important part of data analysis. As the saying goes “garbage in, garbage out”. The three metrics are number of features which is the number of unique genes detected low amount of features indicates low quality cells or droplets and at the other side of the spectrum high feature counts indicate cells clumping together. The number of counts is the second of the three, this variable indicates the number of total molecules in a cell. The third metric is percentage of mitochondrial reads. A high concentration of mitochondrial reads often indicates dying cells. The quality control is done by visualizing and sub-setting this is done in figure 1. # Visualize QC metrics as a violin plot VlnPlot(crohns_dissease_seurat, features = c(&quot;nFeaturess_RNA&quot;, &quot;nCounts_RNA&quot;, &quot;percent_mito&quot;), ncol = 3, pt.size = FALSE)+ labs(caption = &quot;Figure 1. QC metrics vizualizing all cells and artifacts in the dataset.&quot;) Filtering cells with 200–2500 features (genes) ensures that cells with sufficient gene detection are included and excluding low-quality or dead cells with few features. At the other side of the spectrum also stopping potential clumps of cells from being in the data set these clumps often exhibit a high number of features. The threshold of &lt;10% mitochondrial RNA likely removes cells in cellular stress or apoptosis. The mean amount of mitochondrial DNA varies between cell types. #setting the limits on exceptable values to select alowing some [10%] mitochondrial dna into the data set subset_crohns_dissease &lt;- subset(crohns_dissease_seurat, subset = nFeaturess_RNA &gt; 200 &amp; nFeaturess_RNA &lt; 2500 &amp; nCounts_RNA &gt; 200 &amp; percent_mito &lt; 10) VlnPlot(subset_crohns_dissease, features = c(&quot;nFeaturess_RNA&quot;, &quot;nCounts_RNA&quot;, &quot;percent_mito&quot;), ncol = 3, pt.size = FALSE)+ labs(caption = &quot;Figure 2. QC metrics vizualizing all cells and artifacts in the subset of the data set&quot;) The data quality is good overall, with most cells falling within expected ranges. Filtering cells with low features, low total counts, or high mitochondrial content will further enhance the dataset quality and make it suitable for downstream analysis. plot1 &lt;- FeatureScatter(subset_crohns_dissease, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;percent_mito&quot;) plot2 &lt;- FeatureScatter(subset_crohns_dissease, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;nFeaturess_RNA&quot;) plot1 + NoLegend() + plot2 + NoLegend()+ labs(caption = &quot;Figure 3. Scatterplots showing QC metrics distributions across cells&quot;) 2.4 Preperations Normalization, making data human readable and preparing the data for future functions. Find variable features The FindVariableFeatures function in Seurat is used to identify genes that exhibit high variability across cells in a given dataset, which are likely to be biologically significant using the selection method vst. From the seurat website: “ vst: First, fits a line to the relationship of log(variance) and log(mean) using local polynomial regression (loess). Then standardizes the feature values using the observed mean and expected variance (given by the fitted line). Feature variance is then calculated on the standardized values after clipping to a maximum (see clip.max parameter). ” After that extracting the variable features and storing the top 7 as an object in R. # Normalize the data norm_subset_crohns_dissease &lt;- NormalizeData(subset_crohns_dissease) # Find variable features FVF_crohns_dissease &lt;- FindVariableFeatures(norm_subset_crohns_dissease, selection.method = &quot;vst&quot;) variable_features &lt;- VariableFeatures(FVF_crohns_dissease) top7_gene_names &lt;- head(variable_features, 7) 2.5 Variable features plot Feature plot is used to visualize the most variable genes in the dataset, using Seurat’s VariableFeaturePlot function. The plot displays the variation in gene expression across cells the top 7 genes are displayed with their gene symbol. # Plot variable features plot3 &lt;- VariableFeaturePlot(FVF_crohns_dissease) # Label points with gene names using the build in solution instead of to 10 gene names plot4 &lt;- LabelPoints( plot = plot3, points = head(variable_features, 7), labels = head(FVF_crohns_dissease@assays$RNA@meta.features$gene_symbols, 7), repel = TRUE ) # Display the plot plot4+ labs(caption = &quot;Figure 4. Variable features plot with top 7 genes&quot;) 2.6 PCA The Scale Data function scales data before dimensional reduction techniques like PCA. It ensures that highly-expressed genes don’t dominate. Otherwise the results can be skewed. all.genes &lt;- rownames(FVF_crohns_dissease) scaled_data &lt;- ScaleData(FVF_crohns_dissease, features = all.genes) pca_crohns &lt;- RunPCA(scaled_data, features = VariableFeatures(object = scaled_data)) Choosing the right amount of dimensions to analyse and visualize is important. This is done by manually looking at the elbow plot in Figure 5. I choose 15 PC’s because the Elbow plot shows that the first few principal components (PCs) have much higher variance (standard deviation), while later PCs explain less of the variance. By selecting 15 components, you keep most of the important information while reducing the amount of processing power needing to be used. ElbowPlot(pca_crohns)+ labs(caption = &quot;Figure 5. Elbow plot showing the standard deviation of each principal component (PC)&quot;) The scatterplot in Figure 6 depicts the first two principal components (PC1 and PC2), showcasing the variance PC1 and PC2 represent. DimPlot(pca_crohns, dims = c(1,2), reduction = &quot;pca&quot;) + NoLegend()+ labs(caption = &quot;Figure 6. Principal Component Analysis (PCA) Plot&quot;) ## Reductional assays Seurat generates heatmaps to visualize the expression of the genes per PC, PC1 through PC6 due to displaying issues. # Plot the heatmapof the first 6 pc&#39;s DimHeatmap(pca_crohns, dims = 1:6, cells = 500, balanced = TRUE, combine = FALSE) # Add caption grid.text(&quot;Figure 7. Heatmaps of the top 6 Principal Components&quot;, x = 0.5, y = 0.01, just = &quot;center&quot;, gp = gpar(fontsize = 10)) Firstly the FindNeighbors and FindClusters functions are applied to make/calculate the clusters. Here after the UMAP was made using the RunUMAP function to project the data into a dimplot readable frame so it can be displayed into Figure 7 using dimplot. DimPlot function was employed to visualize the UMAP projection, with cells colored by their respective clusters. umap_data_crohns &lt;- FindNeighbors(pca_crohns, dims = 1:15) umap_data_crohns &lt;- FindClusters(umap_data_crohns, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 29915 ## Number of edges: 937472 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9079 ## Number of communities: 19 ## Elapsed time: 8 seconds umap_fig_crohns &lt;- RunUMAP(umap_data_crohns, dims = 1:15) # Generate the UMAP plot umap_plot &lt;- DimPlot(umap_fig_crohns, reduction = &quot;umap&quot;) # Create the caption as a text grob caption_umap &lt;- textGrob(&quot;Figure 8. UMAP Clustering of Crohn’s Disease Dataset&quot;, gp = gpar(fontsize = 10), just = &quot;center&quot;) # Arrange the plot and caption in a grid grid.arrange(umap_plot, caption_umap, ncol = 1, heights = c(10, 1)) # run this code if you do not have this RDS file # find markers for every cluster compared to all remaining cells, report only the positive ones #This took me 2 hours and 21 minutes # if wanting to do this yourself run this code first to be more efficient with your time #library(devtools) #devtools::install_github(&#39;immunogenomics/presto&#39;) crohns.markers &lt;- FindAllMarkers(umap_fig_crohns, only.pos = TRUE) # Save the results in an .rds file saveRDS(crohns.markers, file = &quot;~/school/DSFB2/dsfb2_workflows_portfolio/data/crohns.markers.rds&quot;) Making an enormous heatmap that takes the top five genes per cluster into account. crohns.markers &lt;- readRDS(&quot;~/school/DSFB2/dsfb2_workflows_portfolio/data/crohns.markers.rds&quot;) ##################### because most of the &quot;top genes&quot; all have a p-adjusted value of what the computer stores as zero I decided to arrange the table to also include the highest avg. log2 fold change #crohns.markers %&gt;% # group_by(cluster) %&gt;% # dplyr::filter(avg_log2FC &gt; 1) %&gt;% # distinct(gene) %&gt;% # slice_head(n = 5) %&gt;% # ungroup() -&gt; top5 top5_genes &lt;- crohns.markers %&gt;% group_by(cluster) %&gt;% arrange(p_val_adj, desc(avg_log2FC)) %&gt;% # Sort by lowest p_val_adj and then highest avg_log2FC dplyr::filter(avg_log2FC &gt; 1) %&gt;% distinct(gene) %&gt;% slice_head(n = 5) %&gt;% ungroup() DoHeatmap(umap_fig_crohns, features = top5_genes$gene) + NoLegend() # Add caption grid.text(&quot;Figure 9. Heatmap of Top 5 Marker Genes Across Clusters&quot;, x = 0.5, y = 0.01, just = &quot;center&quot;, gp = gpar(fontsize = 10)) "],["curriculum-vitae-ffr.html", "3 Curriculum vitae FFR 3.1 Personalia verander zodat er meer is over bioinfo 3.2 Opleiding 3.3 Werkervaring", " 3 Curriculum vitae FFR 3.1 Personalia verander zodat er meer is over bioinfo Naast mijn studie Life Sciences ben ik op zoek naar mogelijkheden om mijn werkervaring verder uit te breiden, met een focus op bioinformatica. Ik heb ervaring in programmeren met R, inclusief R Markdown voor data-analyse en rapportage, evenals C# en Java voor softwareontwikkeling. Ik ben analytisch, nieuwsgierig en altijd bereid om nieuwe technieken te leren. Tijdens mijn opleiding heb ik gewerkt met apparaten zoals de PCR en de BIO-RAD thermal cycler. Daarnaast heb ik onder begeleiding van J. B. uitgebreide ervaring opgedaan met de diagnostiek van virussen, met name door het uitvoeren van qPCR-analyses op patiëntmateriaal. 3.2 Opleiding 2019-2024 HBO Biologie en Medisch Laboratoriumonderzoek 2014-2019 Tweetalig Havo op het Anna van Rijn Lyceum, Nieuwegein Studierichting: - Natuur &amp; Techniek en Natuur en Gezondheid - Met informatica - IB English B 3.3 Werkervaring 2024 LUMC research technician 2023-2024 Stage: LUMC, LUCID onder suppervisie van Rajagopal A. Murugan 2021-2023 Particuliere studiebegeleider 2023 Stage: IJsselland ziekenhuis microbiologische laboratorium 2019-2021 Verkoopmedewerker Kruidvat Montfoort 2019 Freelancer Go:Office 2018 Bakkerij Jan van Dommelen 2017-2018 Oppas 2015-2016 Hockey training Contact info name lastname dummy@xs4all.nl Tel: +31 6 12 34 56 78 straatnaam 910 1112AB C-oude 13-14-2015 "],["seurat.html", "4 Seurat", " 4 Seurat The Seurat package is an R package that is designed for analysis and visualization of single-cell RNA sequencing (scRNA-seq) data. It is possible to do data normalization, dimensionality reduction (like, PCA and UMAP) and for other forms of analyses (omic if I get to it). I will be using this (https://satijalab.org/seurat/articles/pbmc3k_tutorial) tutorial to start learning the Seurat package. I quote “we will be analyzing the a dataset of Peripheral Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. There are 2,700 single cells that were sequenced on the Illumina NextSeq 500. The raw data can be found here(https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz).” library(dplyr) library(tidyverse) library(Seurat) #install.packages(&quot;Seurat&quot;) library(patchwork) #install.packages(&quot;patchwork&quot;) library(here) # Load the PBMC dataset pbmc.data &lt;- Read10X(data.dir = &quot;Rmd_files/Seurat_10x_data/filtered_gene_bc_matrices/hg19/&quot;) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) ## 1 layer present: counts # Lets examine a few genes in the first thirty cells pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 30 column names &#39;AAACATACAACCAC-1&#39;, &#39;AAACATTGAGCTAC-1&#39;, &#39;AAACATTGATCAGC-1&#39; ... ]] ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . dense.size &lt;- object.size(as.matrix(pbmc.data)) #object.size(): Calculates the memory size of the dense matrix in bytes. #as.matrix(pbmc.data): Converts pbmc.data to a dense matrix format were as normally a parse matrix is used because it takes up less storage/memory sparse.size &lt;- object.size(pbmc.data) sparse.size ## 29905192 bytes #print parse matrix dense.size ## 709591472 bytes #print dense matrix dense.size/sparse.size ## 23.7 bytes #The dense matrix is 23.7 times bigger than the parse # The [[ operator can add columns to object metadata. This is a great place to stash QC stats pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) # Show QC metrics for the first 5 cells head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 # Visualize QC metrics as a violin plot VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; ## utilizing &quot;counts&quot; layer instead. # FeatureScatter is typically used to visualize feature-feature relationships, but can be used # for anything calculated by the object, i.e. columns in object metadata, PC scores etc. plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;, plot.cor = TRUE) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;, plot.cor = TRUE) plot1 + plot2 There are various ways of generating qualtity control metrics. The tutorial suggests filtering away feature counts over 2500 and under 200 and mitochondrial counts higher than 5%. #selecting the subset of data wanted subset_pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) #normalizing the data as to make the numbers more human readable norm_subset_pbmc &lt;- NormalizeData(subset_pbmc) ## Normalizing layer: counts FVF_pbmc &lt;- FindVariableFeatures(norm_subset_pbmc, selection.method = &quot;vst&quot;) ## Finding variable features for layer counts # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(FVF_pbmc)) # plot variable features with and without labels plot3 &lt;- VariableFeaturePlot(FVF_pbmc) plot4 &lt;- LabelPoints(plot = plot3, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results plot3 + NoLegend() + plot4 ## Warning in scale_x_log10(): log-10 transformation introduced ## infinite values. ## log-10 transformation introduced ## infinite values. #retrieve all gene names all.genes &lt;- rownames(FVF_pbmc) #Scales and centers features in the dataset. scaled_FVF_pbmc &lt;- ScaleData(FVF_pbmc, features = all.genes) ## Centering and scaling data matrix #Run a PCA dimensionality reduction. For details about stored PCA calculation parameters PCA_pbmc &lt;- RunPCA(scaled_FVF_pbmc, features = VariableFeatures(object = scaled_FVF_pbmc)) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL, FTH1, LYZ, FCN1, S100A9, TYMP ## FCER1G, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, IFITM3, SPI1, CFP ## PSAP, IFI30, SAT1, COTL1, S100A11, NPC2, GRN, LGALS3, GSTP1, PYCARD ## Negative: MALAT1, LTB, IL32, IL7R, CD2, B2M, ACAP1, CD27, STK17A, CTSW ## CD247, GIMAP5, AQP3, CCL5, SELL, TRAF3IP3, GZMA, MAL, CST7, ITM2A ## MYC, GIMAP7, HOPX, BEX2, LDLRAP1, GZMK, ETS1, ZAP70, TNFAIP8, RIC3 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1, HLA-DRA, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DMA, HLA-DPB1, HLA-DQA2, CD37, HLA-DRB5, HLA-DMB, HLA-DPA1, FCRLA, HVCN1, LTB ## BLNK, P2RX5, IGLL5, IRF8, SWAP70, ARHGAP24, FCGR2B, SMIM14, PPP1R14A, C16orf74 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA, FGFBP2, CTSW, GNLY, B2M, SPON2 ## CCL4, GZMH, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX ## TTC38, APMAP, CTSC, S100A4, IGFBP7, ANXA1, ID2, IL32, XCL1, RHOC ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, HLA-DPA1, CD74, MS4A1, HLA-DRB1, HLA-DRA ## HLA-DRB5, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, CD37, HVCN1, FCRLA, IRF8 ## PLAC8, BLNK, MALAT1, SMIM14, PLD4, P2RX5, IGLL5, LAT2, SWAP70, FCGR2B ## Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU ## HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, PTCRA, CA2, ACRBP, MMD, TREML1 ## NGFRAP1, F13A1, SEPT5, RUFY1, TSC22D1, MPP1, CMTM5, RP11-367G6.3, MYL9, GP1BA ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1, CD74, HIST1H2AC, HLA-DPB1, PF4, SDPR ## TCL1A, HLA-DRB1, HLA-DPA1, HLA-DQA2, PPBP, HLA-DRA, LINC00926, GNG11, SPARC, HLA-DRB5 ## GP9, AP001189.4, CA2, PTCRA, CD9, NRGN, RGS18, CLU, TUBB1, GZMB ## Negative: VIM, IL7R, S100A6, IL32, S100A8, S100A4, GIMAP7, S100A10, S100A9, MAL ## AQP3, CD2, CD14, FYB, LGALS2, GIMAP4, ANXA1, CD27, FCN1, RBP7 ## LYZ, S100A11, GIMAP5, MS4A6A, S100A12, FOLR3, TRABD2A, AIF1, IL8, IFI6 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY, CCL4, CST7, PRF1, GZMA, SPON2 ## GZMH, S100A9, LGALS2, CCL3, CTSW, XCL2, CD14, CLIC3, S100A12, RBP7 ## CCL5, MS4A6A, GSTP1, FOLR3, IGFBP7, TYROBP, TTC38, AKR1C3, XCL1, HOPX ## Negative: LTB, IL7R, CKB, VIM, MS4A7, AQP3, CYTIP, RP11-290F20.3, SIGLEC10, HMOX1 ## LILRB2, PTGES3, MAL, CD27, HN1, CD2, GDI2, CORO1B, ANXA5, TUBA1B ## FAM110A, ATP1A1, TRADD, PPA1, CCDC109B, ABRACL, CTD-2006K23.1, WARS, VMO1, FYB # Examine and visualize PCA results a few different ways print(PCA_pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 #Visualize the top genes and the first two principle components VizDimLoadings(PCA_pbmc, dims = 1:2, reduction = &quot;pca&quot;) #A PCA plot depicting the each cell and where they get position measured against PC1 and PC2 DimPlot(PCA_pbmc, reduction = &quot;pca&quot;) + NoLegend() DimHeatmap(PCA_pbmc, dims = 1, cells = 500, balanced = TRUE) #By suggesting to the DimHeatmap function to look at PC1 through 15 it will try to fit 15 heatmaps based on the PC previously calculated in PCA_pbmc DimHeatmap(PCA_pbmc, dims = 1:15, cells = 500, balanced = TRUE) ## Dementionality Determining the amount of PC that need to be used is important as to not have a overly computationally expensive. The more PC’s used has diminishing marginal results. This can be done visually by using ElbowPlot(). Alot of the deviation in the graphs can be explained in the first 10 of the principle coordinates. The differences produced in PC 10 - 20 are less distinctionable from background than the first 10. ElbowPlot(PCA_pbmc) findneighbour_pbmc &lt;- FindNeighbors(PCA_pbmc, dims = 1:10) # selecting the top 10 pc&#39;s ## Computing nearest neighbor graph ## Computing SNN clustered_pbmc &lt;- FindClusters(findneighbour_pbmc, resolution = 0.5) # clustering the PC&#39;s ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds rUMAP_pbmc &lt;- RunUMAP(clustered_pbmc, dims = 1:10) ## 18:07:58 UMAP embedding parameters a = 0.9922 b = 1.112 ## 18:07:58 Read 2638 rows and found 10 numeric columns ## 18:07:58 Using Annoy for neighbor search, n_neighbors = 30 ## 18:07:58 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 18:07:58 Writing NN index file to temp file C:\\Users\\ffrij\\AppData\\Local\\Temp\\RtmpUbPK5v\\file67e04b356a48 ## 18:07:58 Searching Annoy index using 1 thread, search_k = 3000 ## 18:07:59 Annoy recall = 100% ## 18:07:59 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 18:08:00 Initializing from normalized Laplacian + noise (using RSpectra) ## 18:08:00 Commencing optimization for 500 epochs, with 105140 positive edges ## 18:08:07 Optimization finished # note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(rUMAP_pbmc, reduction = &quot;umap&quot;) cluster2.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 2) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.892340e-90 1.3070772 0.947 0.465 3.966555e-86 ## LTB 1.060121e-86 1.3312674 0.981 0.643 1.453850e-82 ## CD3D 8.794641e-71 1.0597620 0.922 0.432 1.206097e-66 ## IL7R 3.516098e-68 1.4377848 0.750 0.326 4.821977e-64 ## LDHB 1.642480e-67 0.9911924 0.954 0.614 2.252497e-63 # find all markers distinguishing cluster 5 from clusters 0 and 3 cluster5.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 5, ident.2 = c(0, 3)) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 8.246578e-205 6.794969 0.975 0.040 1.130936e-200 ## IFITM3 1.677613e-195 6.192558 0.975 0.049 2.300678e-191 ## CFD 2.401156e-193 6.015172 0.938 0.038 3.292945e-189 ## CD68 2.900384e-191 5.530330 0.926 0.035 3.977587e-187 ## RP11-290F20.3 2.513244e-186 6.297999 0.840 0.017 3.446663e-182 pbmc.markers &lt;- FindAllMarkers(rUMAP_pbmc, only.pos = TRUE) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows # find markers for every cluster compared to all remaining cells, report only the positive ones pbmc.markers &lt;- FindAllMarkers(rUMAP_pbmc, only.pos = TRUE) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows cluster0.markers &lt;- FindMarkers(rUMAP_pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) VlnPlot(rUMAP_pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) # you can plot raw counts as well VlnPlot(rUMAP_pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) ## Warning: The `slot` argument of `VlnPlot()` is ## deprecated as of Seurat 5.0.0. ## ℹ Please use the `layer` argument ## instead. ## This warning is displayed once every 8 ## hours. ## Call ## `lifecycle::last_lifecycle_warnings()` ## to see where this warning was generated. FeaturePlot(rUMAP_pbmc, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot;)) pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 10) %&gt;% ungroup() -&gt; top10 DoHeatmap(rUMAP_pbmc, features = top10$gene) + NoLegend() new.cluster.ids &lt;- c(&quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot;) names(new.cluster.ids) &lt;- levels(rUMAP_pbmc) top10_genes_pbmc &lt;- RenameIdents(rUMAP_pbmc, new.cluster.ids) DimPlot(top10_genes_pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
